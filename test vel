package.path = string.format('%s/Scripts/rtk/1/?.lua;%s?.lua;', reaper.GetResourcePath(), entrypath)
require 'rtk'
local wnd = rtk.Window{
    w = 480,
    h = 280,
    title = 'multi-k',
}
wnd:open()





















local line = wnd:add(rtk.HBox{})
local vert_box_c1 = line:add(rtk.VBox{y=20})
local vert_box_c2 = line:add(rtk.VBox{y=20})


local shelf_1 = vert_box_c1:add(rtk.HBox{x=25})
local shelf_2 = vert_box_c1:add(rtk.HBox{y=15})

local shelf_3 = vert_box_c2:add(rtk.HBox{x=25})
local shelf_4 = vert_box_c2:add(rtk.VBox{spacing=10,padding=10,border='gray',y=27})





local take = reaper.MIDIEditor_GetTake(reaper.MIDIEditor_GetActive())
local _, noteCount = reaper.MIDI_CountEvts(take)



function modifyVelocity(take, noteIdx, targetVel)
  targetVel = math.floor(targetVel + 0.5)
  local _, selected, muted, startppqpos, endppqpos, chan, pitch, vel = reaper.MIDI_GetNote(take, noteIdx)
  if vel < targetVel then
    vel = vel + 10
    if vel > targetVel then vel = targetVel end
  elseif vel > targetVel then
    vel = vel - 10
    if vel < targetVel then vel = targetVel end
  end
  if vel > 127 then
    vel = 127
  elseif vel < 1 then
    vel = 1
  end
  reaper.MIDI_SetNote(take, noteIdx, selected, muted, startppqpos, endppqpos, chan, pitch, vel, false)
end


function storeInitialVelocities(take, noteCount)
    local velocities = {}
    for i = 0, noteCount - 1 do
        local _, _, _, _, _, _, _, vel = reaper.MIDI_GetNote(take, i)
        velocities[i + 1] = vel
    end
    return velocities
end

local initialVelocities = {} -- Таблица для исходных значений velocity
local baseTargetVels = {80, 60, 100, 40}
local targetVels =  {80, 60, 100, 40}
local tracksizex = 18
local initialVelocities = storeInitialVelocities(take, noteCount) 
local targetVelocity = {}
local modifiedVelocities = {}



local slider_gr = shelf_3:add(rtk.Slider{value = 0, w = 180,
tooltip = 'Грув', thumbsize = 6, tracksize = tracksizex,
trackcolor = '#b7b1b7', thumbcolor='transparent',color = '#48D1CC',  ticks = false})

slider_gr.onchange = function(self)
  local take = reaper.MIDIEditor_GetTake(reaper.MIDIEditor_GetActive())
  local _, noteCount = reaper.MIDI_CountEvts(take)
  local selectedNoteCount = reaper.MIDI_EnumSelNotes(take, -1)
  for i = 0, noteCount - 1 do
    local _, selected, _, _, _, _, _, _ = reaper.MIDI_GetNote(take, i)
    if selected or selectedNoteCount == -1 then
      -- Используем количество элементов в targetVels для определения типа ноты
      local noteType = (i % #targetVels) + 1
      local initialVel = initialVelocities[i + 1]
      if initialVel then
        local targetVel = targetVels[noteType]
        local newVel = initialVel + (targetVel - initialVel) * (self.value / 100)
        if self.value == 0 then newVel = initialVel end
        modifyVelocity(take, i, newVel)
        update_velocity_all()
      end
    end
  end
end

slider_steps_add = shelf_4:add(rtk.Slider{
    value = 4, 
    w = 180,
    min = 1,
    max = 8,
    tooltip = 'Грув',
    thumbsize = 6,
    tracksize = tracksizex,
    trackcolor = '#b7b1b7',
    thumbcolor='transparent',
    color = '#48D1CC',
    ticks = true,
    step=1,
})

local mini_sliders_box = shelf_4:add(rtk.HBox{})
local slider_line_box = mini_sliders_box:add(rtk.VBox{spacing = -5})
local mini_sliders = {}
local mini_sliders_values = {}
local mini_sliders_texts = {}


-- Добавляем переменную для хранения предыдущего значения

function update_slider_steps(self, event)
    if self.value == previous_value then return end
    local step = self.value - slider_steps_add.min + 1
    
    -- Удаляем предыдущие мини-слайдеры и сохраняем их значения
    for i, mini_slider in ipairs(mini_sliders) do
        mini_sliders_values[i] = mini_slider.value
        slider_line_box:remove(mini_slider)
        slider_line_box:remove(mini_sliders_texts[i])
    end
    
    -- Очищаем таблицу мини-слайдеров и текстовых виджетов
    mini_sliders = {}
    mini_sliders_texts = {}
    
    -- Создаем новые мини-слайдеры и текстовые виджеты для них
    for i = 1, step do
        local mini_slider_value = mini_sliders_values[i] or baseTargetVels[i]
        local values_txt = slider_line_box:add(rtk.Text{z=1,y=15,x=2,tostring(mini_slider_value)})
        local mini_slider = slider_line_box:add(rtk.Slider{thumbsize=1,min=0,max=127,step=1,thumbcolor='transparent',tracksize=20,w=170, value=mini_slider_value or 100})
        
        table.insert(mini_sliders, mini_slider)
        table.insert(mini_sliders_texts, values_txt)
        
        -- Обновляем текстовый виджет и массивы при каждом изменении слайдера
        mini_slider.onchange = function(self, event)
            values_txt:attr('text', tostring(self.value))
            baseTargetVels[i] = self.value
            targetVels[i] = self.value
            slider_gr:onchange()
        end
    end
    
    previous_value = self.value
end
local previous_value = slider_steps_add.value
update_slider_steps(slider_steps_add)

slider_steps_add.onchange = function(self, event)
    update_slider_steps(self, event)
end










local function processNotes()
  local velocityMin, velocityMax = slider_range.value[1], slider_range.value[2]
  local take = reaper.MIDIEditor_GetTake(midiEditor)
  local _, noteCount = reaper.MIDI_CountEvts(take)
  local minVelocity, maxVelocity = 127, 1

  for i = 0, noteCount - 1 do
    local _, _, _, startppq, endppq, chan, pitch, vel = reaper.MIDI_GetNote(take, i)
    if not targetVelocity[i] then
      targetVelocity[i] = math.random(velocityMin, velocityMax)
    end

    if buttonchik.pressed then
      local newVelocity = vel + math.random(2, 6) * (targetVelocity[i] < vel and -1 or 1)
      newVelocity = math.max(1, math.min(127, newVelocity))
      reaper.MIDI_SetNote(take, i, nil, nil, startppq, endppq, chan, pitch, newVelocity, false)
    end
    
    minVelocity = math.min(minVelocity, targetVelocity[i])
    maxVelocity = math.max(maxVelocity, targetVelocity[i])
  end

  reaper.MIDI_Sort(take)

  slider_range:attr('value', {minVelocity, maxVelocity})
  min:attr('text', minVelocity)
  max:attr('text', maxVelocity)
end


local slider22 = shelf_1:add(rtk.Slider{value = 0, w = 180,
tooltip = 'ранд', thumbsize = 6, tracksize = tracksizex,
trackcolor = '#b7b1b7', thumbcolor='transparent',color = 'green',  ticks = false})

local buttonchik = shelf_1:add(rtk.Button{'hey'})

local min = shelf_2:add(rtk.Text{'25', w=25})
local slider_range = shelf_2:add(rtk.Slider{
  value={10, 120}, min=0, max=127, step=1, w = 180,
  thumbsize = 6, tracksize = tracksizex,
  trackcolor = '#b7b1b7', thumbcolor='transparent',tooltip='ранг', color = '#48D1CC', ticks = false
})

local max = shelf_2:add(rtk.Text{'120', w=25})



local midiEditor = reaper.MIDIEditor_GetActive()
if not midiEditor then return reaper.MB("No active MIDI Editor found", "Error", 0) end

local take = reaper.MIDIEditor_GetTake(midiEditor)
if not take then return reaper.MB("No take found in MIDI Editor", "Error", 0) end

local _, noteCount = reaper.MIDI_CountEvts(take)
local notesTable = {}
function update_velocity_all()
    for i = 0, noteCount - 1 do
      local _, _, muted, startppq, endppq, chan, pitch, vel = reaper.MIDI_GetNote(take, i)
      local targetVelocity = math.random(10, 126)
      notesTable[i] = {idx = i, muted = muted, startppq = startppq, endppq = endppq, chan = chan, pitch = pitch, velocity = vel, targetVelocity = targetVelocity, initialVelocity = vel}
    end
end
update_velocity_all()
local function moveVelocity()
  local sliderValue = slider22.value
  local velocityRange = slider_range.value
  local anySelected = false
  for _, note in pairs(notesTable) do
    local _, selected = reaper.MIDI_GetNote(take, note.idx) -- Проверяем, выделена ли нота
    anySelected = anySelected or selected
  end

  for i, note in pairs(notesTable) do
    local _, selected = reaper.MIDI_GetNote(take, note.idx) -- Проверяем, выделена ли нота
    if selected or not anySelected then -- Если ни одна нота не выделена, влияем на все ноты
      local currentVelocity = note.velocity
      local targetVelocity = note.targetVelocity
      local initialVelocity = note.initialVelocity

      -- Вычисляем новую величину velocity на основе линейной интерполяции между исходной и целевой, учитывая диапазон из slider_range
      local newVelocity = initialVelocity + (targetVelocity - initialVelocity) * (sliderValue / 100)
      
      newVelocity = math.floor(math.max(velocityRange[1], math.min(velocityRange[2], newVelocity)))
      reaper.MIDI_SetNote(take, note.idx, nil, note.muted, note.startppq, note.endppq, note.chan, note.pitch, newVelocity, false)
      note.velocity = newVelocity
      initialVelocities[i + 1] = newVelocity
    end
  end
  
  reaper.MIDI_Sort(take)
end


local function randomizeTargetVelocities()
  local velocityMin, velocityMax = slider_range.value[1], slider_range.value[2]
  for i, note in pairs(notesTable) do
    note.targetVelocity = math.random(velocityMin, velocityMax)
  end
end


local function deferFunction()

  
  local _, currentNoteCount = reaper.MIDI_CountEvts(take)
  if currentNoteCount ~= noteCount then
    noteCount = currentNoteCount
    notesTable = {}
    initialVelocities = storeInitialVelocities(take, noteCount) -- Обновляем начальные скорости
  end

  for i = 0, noteCount - 1 do
    local _, selected, muted, startppq, endppq, chan, pitch, vel = reaper.MIDI_GetNote(take, i)
    if notesTable[i] then
      notesTable[i].startppq = startppq
      notesTable[i].endppq = endppq
      notesTable[i].pitch = pitch
      notesTable[i].velocity = vel -- Обновляем текущую скорость
    else
      local targetVelocity = math.random(10, 126)
      notesTable[i] = {idx = i, selected = selected, muted = muted, startppq = startppq, endppq = endppq, chan = chan, pitch = pitch, velocity = vel, targetVelocity = targetVelocity, initialVelocity = vel}
    end
  end
  --initialVelocities = storeInitialVelocities(take, noteCount) -- Обновляем начальные скорости
  reaper.defer(deferFunction)
end

deferFunction()

buttonchik.onclick = function()
  randomizeTargetVelocities() -- Рандомизируем целевые значения velocity для всех нот при нажатии кнопки
  moveVelocity() -- Обновляем velocity нот в соответствии с новыми целевыми значениями
  --update_velocity_all()
end


slider_range.onchange = function(self)
    min:attr('text', self.value[1])
    max:attr('text', self.value[2])
    moveVelocity() -- обновляем velocity нот в соответствии с новым диапазоном
end
slider22.onchange = function(self)
    moveVelocity()
end
