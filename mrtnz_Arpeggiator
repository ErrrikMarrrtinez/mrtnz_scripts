package.path = string.format('%s/Scripts/rtk/1/?.lua;%s?.lua;', reaper.GetResourcePath(), entrypath)
require 'rtk'
local resourcePath = reaper.GetResourcePath()
package.path = package.path .. ";" .. resourcePath .. "/Scripts/?.lua"
local json = require("json")
reaper.GetSetProjectInfo_String(0, "PROJOFFS", "0", true)


base_color = "#3a3a3a"
base_wight_button = 94


advanced_color_current = base_color
advanced_color_pressed = "#6d694f"

legato_color_current = base_color
legato_color_pressed = "#4a544d" 

auto_apply_color_current="#322a26"
auto_apply_color_pressed="#211c1a"

generate_color_current = "#3d342f"
generate_color_pressed = "#220a04"

modes_button_color_current = base_color
modes_button_color_pressed = "#443433"

knob_rate_label_color = "white"
main_background_color = "#1a1a1a"

advanced_color_main_sl_label="orange"

adv_mode_bg_window = "#242424"


adv_mode_x=-10
adv_mode_y=67
adv_mode_w=150
adv_mode_h=100

adv_thumb_size=5
adv_track_size=7
adv_color=advanced_color_main_sl_label
adv_thumbcolor="transparent"
adv_slider_w=110
adv_fontsize=16



local wnd = rtk.Window{
    w = 355,
    h = 500,
    title = 'arp',
bg = main_background_color
}

local grid = 3840 --размер основных нот

local mode = "down" --направление
local grid_step = 240 --размер для шага step
local step = 3 --шаг для отклонения grid_step, каждая step нота будет иметь длину grid_step
local octave = 0 --взрыв октав
local step_mode = 1 --чекснизу
local velocity = 100
local extendNotesFlag = false --легато
local grid_values = {1920, 1280, 960, 640, 480, 320, 240, 160, 120, 80, 60}
--[[
===step modes===
     1 - когда используется только grid
     2 - когда используется grid, step, grid_step
     3 - когда исполььзуется grid, step, grid_step в множественном числе в виде таблицы или массива
]]
local step_grid = {
  { -- Для первого аккорда
    mode = "down",
    {step = 1, grid_step = 480, velocity = 20, octave = -2, ratchet = 0},
    {step = 2, grid_step = 480, velocity = 50, octave = -1, ratchet = 0},
    {step = 3, grid_step = 240, velocity = 70, octave = 0, ratchet = 0},
    {step = 4, grid_step = 960, velocity = 110, octave = 1, ratchet = 6},
  },
  { -- Для второго аккорда
    mode = "up",
    {step = 1, grid_step = 960, velocity = 25, octave = 0, ratchet = 6},
    {step = 2, grid_step = 240, velocity = 35, octave = 1, ratchet = 3},
    {step = 3, grid_step = 480, velocity = 45, octave = -1, ratchet = 8},
    {step = 4, grid_step = 240, velocity = 65, octave = 0, ratchet = 5},
  },
}







--[[
===modes===
- up
- down
- random
]]

--[[
===grid sizes===

- 1/1 - 3840
- 1/2 - 1920
- 1/3 - 1280
- 1/4 - 960
- 1/6 - 640
- 1/8 - 480
- 1/12 - 320
- 1/16 - 240
- 1/24 - 160
- 1/32 - 120
- 1/48 - 80
- 1/64 - 60
]]



function makeDarker(color, amount)
        local r, g, b = color:match("#(%x%x)(%x%x)(%x%x)")
        r = math.floor(math.max(0, tonumber(r, 16) * (1 - amount)))
        g = math.floor(math.max(0, tonumber(g, 16) * (1 - amount)))
        b = math.floor(math.max(0, tonumber(b, 16) * (1 - amount)))
        return string.format("#%02x%02x%02x", r, g, b)
end

rtk.add_image_search_path('../../MrtnzScripts/NotePast/images', 'dark')
local up = rtk.Image.icon('up'):scale(120,120,22,7) -- increase the size of the image
local down = rtk.Image.icon('down'):scale(120,120,22,7) -- increase the size of the image
local rand = rtk.Image.icon('rand'):scale(120,120,22,7) -- increase the size of the image
local rnd = rtk.Image.icon('rnd'):scale(120,120,22,7) -- increase the size of the image
local oct = rtk.Image.icon('oct'):scale(120,120,22,7) -- increase the size of the image
local leg = rtk.Image.icon('leg'):scale(120,120,22,7) -- increase the size of the image
local save = rtk.Image.icon('save'):scale(120,120,22,7) -- increase the size of the image
local delete = rtk.Image.icon('trash'):scale(120,120,22,7) -- increase the size of the image
local page = rtk.Image.icon('page'):scale(120,120,22,7) -- increase the size of the image
local gen11 = rtk.Image.icon('gear'):scale(120,120,22,7) -- increase the size of the image
local gen22 = rtk.Image.icon('gear_l'):scale(120,120,22,7) -- increase the size of the image
local gen_pp = rtk.Image.icon('gen_p'):scale(120,120,22,7) -- increase the size of the image
local bulb = rtk.Image.icon('bulb1'):scale(120,120,22,7) -- increase the size of the image
local bulb2 = rtk.Image.icon('bulb2'):scale(120,120,22,7) -- increase the size of the image
local bulb_en = rtk.Image.icon('bulb_en'):scale(120,120,22,7) -- increase the size of the image

local on = rtk.Image.icon('on'):scale(120,120,22,7) -- increase the size of the image
local off = rtk.Image.icon('off'):scale(120,120,22,7) -- increase the size of the image
local onof = rtk.Image.icon('onof'):scale(120,120,22,7) -- increase the size of the image

local onm = rtk.Image.icon('onm'):scale(120,120,22,7) -- increase the size of the image

local up_and_down = rtk.Image.icon('up-and-down'):scale(120,120,22,7) -- increase the size of the image
font="Trebuchet MS"
local container = wnd:add(rtk.VBox{y=-35})

local vbox2 = container:add(rtk.VBox{y=50,padding=5,x=wnd.w/2-50})

local vbox = container:add(rtk.VBox{})

hb_o = vbox:add(rtk.HBox{y=60,x=10,spacing=2,padding=25})
color_b_hb = "#3a3a3a"

bt2_btgen = hb_o:add(rtk.HBox{w=base_wight_button})

local button2 = bt2_btgen:add(rtk.Button{
    gradient=3,
    color=auto_apply_color_current,
    spacing=2,
    padding=4,
    font="Trebuchet MS",
    tagged=true,
    icon=on,
    h=29,
    w=base_wight_button,
    halign='center',
    label='Auto Apply',
    
    })
    
    
    
local btn_generate = bt2_btgen:add(rtk.Button{
    gradient=4,
    color=generate_color_current,
    spacing=2,
    padding=4,
    font="Trebuchet MS",
    tagged=true,
    icon=gen,
    h=29,
    w=2,
    halign='center',
    label='Generate',
    cursor=rtk.mouse.cursors.HAND,
})
btn_generate.onmouseenter=function(self)
    self:attr('icon', gen2)
end
btn_generate.onmouseleave=function(self)
    self:attr('icon', gen)
end
btn_generate.onmousedown=function(self)
    self:attr('icon', gen_p)
end
btn_generate.onmouseup=function(self)
    self:attr('icon', gen2)
end
btn_generate.onclick=function(self)
    run()
end



advanced_slid_b=hb_o:add(rtk.VBox{})
local button_adv = advanced_slid_b:add(rtk.Button{
        gradient=3,
        color=advanced_color_current,
        spacing=2,
        padding=4,
        font="Trebuchet MS",
        tagged=true,
        icon=bulb,
        h=29,
        w=base_wight_button,
        halign='center',
        label='Advanced',
        z=1,

})
advanced_slider_slider=advanced_slid_b:add(rtk.VBox{h=1.1})
local new_color_advanced = makeDarker("#6d694f", -0.5)




local slider_mod_advanced = advanced_slider_slider:add(rtk.Slider{
  w=base_wight_button/10,
  thumbcolor='transparent',
  color=new_color_advanced,
  thumsize=0.2,
  h=1.1,
  min=1,
  max=3,
  step=1,
  tracksize=2,
  value=2,
  hotzone=1,
  lhotzone=1,
  --cursor=rtk.mouse.cursors.REAPER_BORDER_RIGHT,
})
slider_mod_advanced.onmouseenter=function(self)
  
end
slider_mod_advanced:onblur()
slider_mod_advanced:hide()
slider_mod_advanced.onchange = function(self, event)
    --self:attr('disabled', true)
end

slider_mod_advanced.onmousewheel = function(self, event)
    local _, _, _, wheel_y = tostring(event):find("wheel=(%d+.?%d*),(-?%d+.?%d*)")
    local c_val = tonumber(wheel_y) > 0 and self.value - self.step or self.value + self.step
    self:attr('value', math.max(self.min, math.min(self.max, c_val)))
    return true
end





button_adv.state = 1
button_adv.current_icon = bulb



button_adv.onmousedown = function(self, event)
    self:attr('icon', bulb_en)  -- Изменение иконки при нажатии кнопки
end

button_adv.onmouseup = function(self, event)
    self:attr('icon', self.current_icon)  -- Восстановление текущей иконки после отпускания кнопки
end

button_adv.onmouseleave = function(self, event)
    self:attr('icon', self.current_icon)  -- Восстановление текущей иконки при уходе курсора
    self:attr("cursor", rtk.mouse.cursors.UNDEFINED)
end

button_adv.onmouseenter = function(self, event)  -- При наведении
    self:attr('icon', bulb_en)  -- Изменение иконки на bulb_en
    self:attr("cursor", rtk.mouse.cursors.HAND)
end
        



btn_generate:hide()
local func_on = true
button2.state = "on"
button2.current_icon = on
button2.onclick = function(self, event)
    if self.state == "on" then--выкл
        self.state = "off"
        self:attr('color', auto_apply_color_pressed)
        self:attr('icon', off)
        self:attr('gradient', 5)
        self.current_icon = off
        func_on = false
        btn_generate:show()
        btn_generate:animate{'w', dst=68, duration=0.2,"out-bounce"}
        button2:animate{'w', dst=26, duration=0.2,"out-bounce"}
        
    else --вкл
        self.state = "on"
        self:attr('color', auto_apply_color_current)
        self:attr('icon', on)
        self.current_icon = on
        func_on = true
        self:attr('gradient', 3)
        button2:animate{'w', dst=base_wight_button, duration=0.2,"out-bounce"}
        btn_generate:animate{'w', dst=15, duration=0.2,"out-bounce"}
           :after(function()
               return btn_generate:hide()
            end)
    end
end

function p_run()
    if func_on == true then
        run()
    end
end

button2.onmousedown = function(self,event)
  self:attr('icon', onof)

end
button2.onmouseup = function(self,event)
  self:attr('icon', self.current_icon)

end
button2.onmouseleave = function(self, event)
  self:attr('icon', self.current_icon)
  self:attr("cursor", rtk.mouse.cursors.UNDEFINED)

end
button2.onmouseenter = function(self, event)
  self:attr('icon', onof)
  self:attr("cursor", rtk.mouse.cursors.HAND)

end

local leg_notes=hb_o:add(rtk.VBox{})
local button_str = leg_notes:add(rtk.Button{
    color=legato_color_current,
    gradient=3,
    spacing=2,
    padding=4,
    font=font,
    tagged=true,
    icon=leg,
    w=base_wight_button,
    halign='center',
    label='Legato',
    h=29,
    z=1,
    })
    
local new_color = makeDarker("#4a544d", -0.5)

local hb_stac_leg = leg_notes:add(rtk.HBox{h=1.1})
slid_length = hb_stac_leg:add(rtk.Slider{
  w=base_wight_button/10,
  thumbcolor='transparent',
  color=new_color,
  thumsize=1,
  h=1.1,
  min=0,
  max=100,
  step=1,
  value=100,
  tracksize=2,
  
})

slid_length.onmousewheel = function(self, event)
    local _, _, _, wheel_y = tostring(event):find("wheel=(%d+.?%d*),(-?%d+.?%d*)")
    local c_val = tonumber(wheel_y) > 0 and self.value - self.step-7 or self.value + self.step+7
    self:attr('value', math.max(self.min, math.min(self.max, c_val)))
    return true
end
local globalSliderValue = 100 
slid_length.onchange = function(self, event)
  amount = self.value / -120
  local new_color = makeDarker("#4a544d", amount)
  self:attr('color', new_color)
  globalSliderValue = self.value

  -- Изменение имени кнопки в зависимости от значения слайдера
  if self.value < 35 then
    button_str:attr('label', 'Staccato')
  else
    button_str:attr('label', 'Legato')
  end
  
  p_run()
end
--slid_length:show()  
button_str.state = "on"
button_str.onclick = function(self, event)
    if self.state == "on" then
        self.state = "off"
        self:attr('color', legato_color_pressed)
        extendNotesFlag = true
        p_run()
        slid_length:show() 
        slid_length:animate{'w', dst=base_wight_button, duration=0.1, easing="in-quad"}
        
    else
        self.state = "on"
        self:attr('color', legato_color_current)
        extendNotesFlag = false
        p_run()
        slid_length:animate{'w', dst=base_wight_button/10, duration=0.1, easing="out-quad"}
        :after(function()
            local function jopa()
               slid_length:hide()
            end
            return jopa()
         end)
        
        
    end
end

button_str.onmouseenter = function(self, event)
    self:attr("cursor", rtk.mouse.cursors.HAND)
end



local v_chords_box = container:add(rtk.VBox{y=20,x=10,spacing=5,padding=25})
local chord_str = v_chords_box:add(rtk.HBox{spacing=5}) --линия тулбара


b_create_chord = chord_str:add(rtk.Button{font=font,halign='center',w=80,tagged=true,icon=page,padding=3,spacing=5,"Create"})
b_save_chord = chord_str:add(rtk.Button{font=font,halign='center',w=80,tagged=true,icon=save,padding=3,spacing=5,"Save"})
b_delete_chord = chord_str:add(rtk.Button{font=font,halign='center',w=80,tagged=true,icon=delete,padding=3,spacing=5,"Delete"})



local chord_b_box = v_chords_box:add(rtk.HBox{x=10,y=10,spacing=5,padding=25}) --линия кнопок
local button_chords = chord_b_box:add(rtk.Button{w=200,"Chord 1"}) --кнопка
--v_chords_box:hide()


v_chords_box:hide()



--[[local slider3 = slider_line:add(rtk.Slider{
tracksize = 10,
ticksize = 1,
thumbcolor='#443433',
thumbsize=8,
trackcolor = '#b7b7b7',
color = '#443433',
step = 1, 
min = 1,
max = 11,
w=250,
ticks = true,

})
local function blurSlider()
  slider3:blur()
  
end

slider3.onmouseup = function()
  blurSlider()
  slider3:attr("thumbcolor", "#443433" )
  slider3:attr("cursor", rtk.mouse.cursors.HAND)
end
slider3.onmousedown = function(self,event)
    blurSlider()
    slider3:attr("thumbcolor","#362a29")
    slider3:attr("cursor", rtk.mouse.cursors.HAND)
end
slider3.onmouseleave = function(self, event)
  blurSlider()
end

slider3.onmouseenter = function(self, event)
  slider3:attr("cursor", rtk.mouse.cursors.HAND)
end
]]

local box_second_advanced = vbox:add(rtk.HBox{})

local slider_line = box_second_advanced:add(rtk.VBox{y=27,spacing=2,padding=25})

local sliders_box_v = box_second_advanced:add(rtk.VBox{bg=adv_mode_bg_window,spacing=2,padding=3,x=adv_mode_x,w=adv_mode_w,h=adv_mode_h,y=adv_mode_y})

slider_first=sliders_box_v:add(rtk.HBox{y=10})



local slider_velocity = slider_first:add(rtk.Slider{
    thumbsize=adv_thumb_size,
    tracksize=adv_track_size,
    color=adv_color,
    step=1,
    min=0,
    max=127,
    w=adv_slider_w,
    thumbcolor=adv_thumbcolor,
    value=100,
})

vel_text=slider_first:add(rtk.Text{fontsize=adv_fontsize,w=28,x=4,"VEL",y=-3})

slider_velocity.onmousewheel = function(self, event)
    local _, _, _, wheel_y = tostring(event):find("wheel=(%d+.?%d*),(-?%d+.?%d*)")
    local c_val = tonumber(wheel_y) > 0 and self.value - self.step or self.value + self.step
    self:attr('value', math.max(self.min, math.min(self.max, c_val)))
    return true
end
slider_velocity.onchange=function(self, event)
  if step_mode == 2 then  -- Проверяем, установлен ли нужный режим
    vel_text:attr('text', self.value)
    velocity = self.value  -- Устанавливаем velocity равным текущему значению слайдера
    p_run()
  end
end

slider_velocity.onmousedown = function(self, event)
  -- Здесь можно добавить дополнительный код, если нужно
end

slider_velocity.onmouseenter = function(self, event)
  if step_mode == 2 then  -- Проверяем, установлен ли нужный режим
    vel_text:attr('text', self.value)
  end
end

slider_velocity.onmouseleave = function(self, event)
  if step_mode == 2 then  -- Проверяем, установлен ли нужный режим
    vel_text:attr('text', 'VEL')
  end
end





sliders_box_v:hide()
slider_sec=sliders_box_v:add(rtk.HBox{y=14,halign='center'})
step_text=slider_sec:add(rtk.Text{fontsize=adv_fontsize,w=30,y=7,"STEP"})
local slider_velocity2 = slider_sec:add(rtk.Slider{
    thumbsize=adv_thumb_size,
    tracksize=adv_track_size,
    color=adv_color,
    x=-1,
    w=adv_slider_w,
    ticksize=2,
    y=11,
    step=1,
    min=2,
    max=8,
    ticks=true,
    thumbcolor=adv_thumbcolor,
    value=3,
    
})
slider_velocity2.onchange=function(self, event)
  if step_mode == 2 then  -- Проверяем, установлен ли нужный режим
    step_text:attr('text', self.value)
    step=self.value
    p_run()
  end
end
slider_velocity2.onmousedown = function(self, event)
  -- Здесь можно добавить дополнительный код, если нужно
end
slider_velocity2.onmousewheel = function(self, event)
    local _, _, _, wheel_y = tostring(event):find("wheel=(%d+.?%d*),(-?%d+.?%d*)")
    local c_val = tonumber(wheel_y) > 0 and self.value - self.step or self.value + self.step
    self:attr('value', math.max(self.min, math.min(self.max, c_val)))
    return true
end

slider_velocity2.onmouseenter = function(self, event)
  if step_mode == 2 then  -- Проверяем, установлен ли нужный режим
    step_text:attr('text', self.value)
  end
end

slider_velocity2.onmouseleave = function(self, event)
  if step_mode == 2 then  -- Проверяем, установлен ли нужный режим
    step_text:attr('text', 'STEP')
  end
end


slider_thr=sliders_box_v:add(rtk.HBox{y=40})
local slider_velocitythr = slider_thr:add(rtk.Slider{
    thumbsize=adv_thumb_size,
    tracksize=adv_track_size,
    color=adv_color,
    step=1,
    min=0,
    max=110,
    w=adv_slider_w,
    thumbcolor=adv_thumbcolor,
    value=0,
    
})
rate_text=slider_thr:add(rtk.Text{w=28,x=4,fontsize=adv_fontsize,"RATE",y=-3})
slider_velocitythr.onchange=function(self, event)
  local index = math.floor(self.value / 10 + 0.5) + 1  -- округляем к ближайшему индексу
  if index < 1 then index = 1 end  -- защита от выхода индекса за пределы массива
  if index > #grid_values then index = #grid_values end
  
  grid_step = grid_values[index]  -- устанавливаем grid_step равным значению из таблицы
  p_run()
end
slider_velocitythr.onmousewheel = function(self, event)
    local _, _, _, wheel_y = tostring(event):find("wheel=(%d+.?%d*),(-?%d+.?%d*)")
    local c_val = tonumber(wheel_y) > 0 and self.value - self.step-9 or self.value + self.step+9
    self:attr('value', math.max(self.min, math.min(self.max, c_val)))
    return true
end
local font="Trebuchet MS"
local vert_b = vbox:add(rtk.HBox{x=10,spacing=2,padding=25})
modes_button_wight = base_wight_button - 15

local b_up = vert_b:add(rtk.Button{cursor=rtk.mouse.cursors.HAND,pacing=5,padding=4,font=font,tagged=true,icon=up,halign='center',w=base_wight_button,'Up'})
local b_down = vert_b:add(rtk.Button{cursor=rtk.mouse.cursors.HAND,spacing=5,padding=4,font=font,tagged=true,icon=down,halign='center',w=base_wight_button,'Down'})
vert_b_line=vert_b:add(rtk.HBox{})
local b_rand = vert_b_line:add(rtk.Button{cursor=rtk.mouse.cursors.HAND,spacing=5,padding=4,font=font,tagged=true,icon=rand,halign='center',w=base_wight_button,'Random'})
local button = vert_b_line:add(rtk.Button{iconpos='left',color=color_b_hb,gradient=3,spacing=5,padding=4,font=font,tagged=true,icon=oct,w=10,h=26,halign='center',label='0'})
button:hide()

b_rand.onmousedown = function()
  b_rand:attr("icon", rnd)
end


b_rand.onmouseup = function()
  b_rand:attr("icon", rand)
end

local gr = 2

button_adv.onclick = function(self, event)
    if self.state == 1 then  -- выкл
        self.state = 2
        self:attr('icon', bulb2)
        self:attr('color', advanced_color_pressed)
        self.current_icon = bulb2
        slider_mod_advanced:show()
        slider_mod_advanced:animate{'w', dst=base_wight_button, duration=0.1, easing="in-quad"}
        step_mode=2
        sliders_box_v:show()
    elseif self.state == 2 then  -- вкл
        self.state = 3  -- переход к третьему состоянию
        self:attr('icon', gen22)  -- тут можешь установить другую иконку для третьего состояния, если нужно
        self:attr('color', '#3f0b0b')  -- красный цвет для третьего состояния
        self.current_icon = gen11
        step_mode=3
        sliders_box_v:hide()
        circt1:hide()
        vert_b:hide()
    else  -- третье состояние
        self.state = 1
        self:attr('icon', bulb)
        self:attr('color', advanced_color_current)
        self.current_icon = bulb
        slider_mod_advanced:animate{'w', dst=base_wight_button/10, duration=0.1, easing="out-quad"}
        :after(function()
            local function jopa2()
               slider_mod_advanced:hide()
            end
            return jopa2()
         end)
         step_mode=1
         sliders_box_v:hide()
         circt1:show()
         vert_b:show()
    end
    slider_mod_advanced:attr('value', button_adv.state)
    slider_mod_advanced:attr('color', button_adv.color)
    p_run()
    
end
function reset_button()
    b_up:attr("color", modes_button_color_current)
    b_down:attr("color",modes_button_color_current)
    b_rand:attr("color",modes_button_color_current)
    b_up:attr("gradient", gr)
    b_down:attr("gradient",gr)
    b_rand:attr("gradient",gr)
    b_rand:attr("hover",false)
    b_up:attr("hover",false)
    b_down:attr("hover",false)
end
function reset_animate_button()
    local def_dur = 0.3
    local eas="out-back"
    b_down:animate{'w', dst=base_wight_button, duration=def_dur, easing=eas}
    b_up:animate{'w', dst=base_wight_button, duration=def_dur, easing=eas}
    b_rand:animate{'w', dst=base_wight_button, duration=def_dur, easing=eas}
end

reset_button()
b_down:attr("color",modes_button_color_pressed)
b_up.onclick=function()
    reset_button()
    b_up:attr("gradient", 3)
    b_up:attr("color",modes_button_color_pressed)
    b_up:attr("hover",true)
    mode = "up"
    button:attr('label', '0')
    octave=0
    p_run()
    button:animate{'color', dst="#3a3a3a", duration=0.25}
    button:animate{'w', dst=15, duration=0.15, easing='out-expo'}  
       :after(function()
           local function after_button()
              button:hide()
              b_rand:animate{'color', dst="#3a3a3a", duration=0.25}
              
              reset_animate_button()
           end
           return after_button()
        end)
end

b_down.onclick=function()
    reset_button()
    b_down:attr("color",modes_button_color_pressed)
    b_down:attr("gradient", 3)
    b_down:attr("hover",true)
    mode = "down"
    button:attr('label', '0')
    octave=0
    p_run()
    button:animate{'color', dst="#3a3a3a", duration=0.25}
    button:animate{'w', dst=10, duration=0.15, easing='in-expo'}  
       :after(function()
           local function after_button()
              button:hide()
              b_rand:animate{'color', dst="#3a3a3a", duration=0.25}
              reset_animate_button()
           end
           return after_button() 
        end)
        
end



b_rand.onclick=function()
    reset_button()
    b_rand:attr("color",modes_button_color_pressed)
    b_rand:animate{'color', dst=modes_button_color_pressed, duration=0.25}
    local def_dur = 0.31
    local eas="in-out-quad"
    b_rand:attr("gradient", 3)
    b_rand:attr("hover",true)
    mode = "random"
    p_run()
    button:show()
    button:animate{'w', dst=45, duration=def_dur, easing=eas}
    
    button:animate{'color', dst=modes_button_color_pressed, duration=0.85}
    button:attr("gradient", 3)
    button:attr("hover",true)
    b_down:animate{'w', dst=modes_button_wight, duration=def_dur, easing=eas}
    b_up:animate{'w', dst=modes_button_wight, duration=def_dur, easing=eas}
    b_rand:animate{'w', dst=modes_button_wight, duration=def_dur, easing=eas}
    
end


local dragging = false
local currentValue = 0
local prevX, prevY = nil, nil

button.ondragstart = function(self, event, x, y, t)
    dragging = true
    prevX, prevY = x, y
      button:attr("cursor", rtk.mouse.cursors.REAPER_MARKER_VERT)
    return true
end

button.onmouseenter = function()
  button:attr("cursor", rtk.mouse.cursors.BEAM)
  button:attr("icon", up_and_down)
end
button.onmouseleave = function()
    button:attr("icon", oct)
end
button.ondragend = function(self, event, dragarg)
    dragging = false
    prevX, prevY = nil, nil
    button:attr("cursor", rtk.mouse.cursors.UNDEFINED)
    
    -- передача значения
    octave = currentValue
    p_run()
end
button.onmousewheel = function(self, event)
    local _, _, _, wheel_y = tostring(event):find("wheel=(%d+.?%d*),(-?%d+.?%d*)")
    wheel_y = tonumber(wheel_y)

    if wheel_y > 0 then
        currentValue = currentValue - 1
    else
        currentValue = currentValue + 1
    end

    currentValue = math.max(0, math.min(6, currentValue))

    button:attr('label', tostring(currentValue))

    -- Здесь передаем значение в octave и запускаем функцию run
    octave = currentValue
    p_run()
    return true
end
local dragAccumulatorX = 0
local dragAccumulatorY = 0
local dragThreshold = 25 -- порог для изменения значения
button.ondragmousemove = function(self, event, dragarg)
    if dragging and prevX and prevY then
            local deltaX = event.x - prevX
            local deltaY = event.y - prevY
            
            dragAccumulatorX = dragAccumulatorX + deltaX
            dragAccumulatorY = dragAccumulatorY + deltaY
    
            if math.abs(dragAccumulatorX) > dragThreshold or math.abs(dragAccumulatorY) > dragThreshold then
            if math.abs(deltaX) > math.abs(deltaY) then

            else
                -- Вертикальное движение
                if deltaY > 0 then
                    currentValue = currentValue - 1
                    button:attr("icon", down)
                elseif deltaY < 0 then
                    currentValue = currentValue + 1
                    button:attr("icon", up)
                end
                dragAccumulatorX = 5
                dragAccumulatorY = 5
            end

            -- Ограничение значения от 1 до 11
            currentValue = math.max(0, math.min(6, currentValue))

            button:attr('label', tostring(currentValue))
            prevX, prevY = event.x, event.y
        end
    end
end


--local grid_values = {1920, 1280, 960, 640, 480, 320, 240, 160, 120, 80, 60}




local resourcePath = reaper.GetResourcePath()
package.path = package.path .. ";" .. resourcePath .. "/Scripts/?.lua"
local json = require("json")
reaper.GetSetProjectInfo_String(0, "PROJOFFS", "0", true)
--------------надо добавить инвертировние
--[[
slider3._previous_value = slider3.value

slider3.onchange = function(self)
    if self.value == slider3._previous_value then return end
    local step = self.value - self.min + 1
    grid = grid_values[step]
    p_run()
    slider3._previous_value = self.value
end

]]

local function save_notes_to_json(filename)
  local take = reaper.MIDIEditor_GetTake(reaper.MIDIEditor_GetActive())
  local pattern = {notes = {}}
  local _, numNotes, _, _ = reaper.MIDI_CountEvts(take)
  for i = 0, numNotes - 1 do
    local _, selected, _, startppqpos, endppqpos, _, pitch, velocity = reaper.MIDI_GetNote(take, i)
    if selected then
      local position = startppqpos
      local length = endppqpos - position
      table.insert(pattern.notes, {position = position, length = length, velocity = velocity, pitch = pitch})
    end
  end
  local jsonString = json.encode(pattern)
  local filePath = resourcePath .. "/Scripts/MrtnzScripts/ArpData/" .. filename
  local file = io.open(filePath, "w")
  if file then
    file:write(jsonString)
    file:close()
    --reaper.ShowMessageBox("Note data has been successfully saved to " .. filename, "Saving", 0)
  else
    reaper.ShowMessageBox("Error opening file.", "Error", 0)
  end
end
local function load_notes(filename)
  local filePath = resourcePath .. "/Scripts/MrtnzScripts/ArpData/" .. filename
  local file_read = io.open(filePath, "r")
  if file_read then
    local content = file_read:read("*all")
    file_read:close()
    return json.decode(content)
  else
    reaper.ShowMessageBox("Error opening file.", "Error", 0)
    return nil
  end
end

local function compare_patterns(pattern1, pattern2)
  if #pattern1.notes ~= #pattern2.notes then return false end
  for i, note1 in ipairs(pattern1.notes) do
    local note2 = pattern2.notes[i]
    if note1.position ~= note2.position or note1.length ~= note2.length or note1.velocity ~= note2.velocity or note1.pitch ~= note2.pitch then
      return false
    end
  end
  return true
end


local function delete_selected_notes(take)
  local _, numNotes, _, _ = reaper.MIDI_CountEvts(take)
  local selected_notes = {}
  
  -- Сначала получаем все выделенные ноты
  for i = 0, numNotes - 1 do
    local _, selected, _, _, _, _, _, _ = reaper.MIDI_GetNote(take, i)
    if selected then
      table.insert(selected_notes, i)
    end
  end
  
  -- Затем удаляем только выделенные ноты
  for i = #selected_notes, 1, -1 do
    reaper.MIDI_DeleteNote(take, selected_notes[i])
  end
end

--------------------------------------

function adjustNoteLengths()
    local take = reaper.MIDIEditor_GetTake(reaper.MIDIEditor_GetActive())
    if not take then return end  -- Выход, если активный редактор MIDI не найден
    
    local _, noteCount, _, _ = reaper.MIDI_CountEvts(take)
    local hasSelectedNotes = false
    
    for i = 0, noteCount - 1 do
        local retval, selected, _, _, _, _, _, _ = reaper.MIDI_GetNote(take, i)
        if selected then
            hasSelectedNotes = true
            break
        end
    end
    local ik=10.1
    for i = 0, noteCount - 1 do
        local retval, selected, muted, startppqpos, endppqpos, chan, pitch, vel = reaper.MIDI_GetNote(take, i)
        if hasSelectedNotes then
            if selected then
                reaper.MIDI_SetNote(take, i, nil, nil, nil, endppqpos - ik, nil, nil, nil, false)
            end
        else
            reaper.MIDI_SetNote(take, i, nil, nil, nil, endppqpos - ik, nil, nil, nil, false)
        end
    end
    
    reaper.MIDI_Sort(take)
end
function extendNotesToEndOfBar(startZone, endZone)
  -- Используем глобальное значение или 100 по умолчанию
  local sliderValue = globalSliderValue or 100

  -- Защита от nil для startZone и endZone
  if not startZone or not endZone then return end

  local midiEditor = reaper.MIDIEditor_GetActive()
  if not midiEditor then return end

  local take = reaper.MIDIEditor_GetTake(midiEditor)
  
  local _, noteCount, _, _ = reaper.MIDI_CountEvts(take)
  local extendTo
  
  for i = 0, noteCount - 1 do
    local retval, sel, muted, startppq, endppq, chan, pitch, vel = reaper.MIDI_GetNote(take, i)
    
    if sel and startppq >= startZone and endppq <= endZone then
      extendTo = endZone
      
      for j = i + 1, noteCount - 1 do
        local _, _, _, startppq2, _, _, pitch2, _ = reaper.MIDI_GetNote(take, j)
        
        if pitch == pitch2 and startppq2 < endZone then
          extendTo = startppq2
          break
        end
      end
      
      -- Рассчитываем новую длину ноты с учетом значения слайдера
      local newLength = extendTo - startppq
      local maxExtendLength = endZone - startppq
      newLength = newLength * (sliderValue / 100)
      
      -- Защита от установки длины меньше 64 тиков и больше максимальной
      newLength = math.max(64, math.min(newLength, maxExtendLength))
      
      -- Рассчитываем новую конечную позицию ноты
      local newExtendTo = startppq + newLength
      
      -- Защита от ситуации, когда конечная позиция меньше начальной
      if newExtendTo > startppq then
        reaper.MIDI_SetNote(take, i, sel, muted, startppq, newExtendTo, chan, pitch, vel, false)
      end
    end
  end
  
  reaper.MIDI_Sort(take)
end

local function splitNote(take, start, endpos, pitch, vel, ratchet)
  local len = endpos - start
  local div = math.floor(len / ratchet)
  local mult_len = start + div * ratchet

  for j = 1, ratchet do
    reaper.MIDI_InsertNote(
      take, 
      true, 
      false, 
      start + (j-1) * div, 
      start + (j-1) * div + div, 
      0, 
      pitch, 
      vel,
      false
    )
    if mult_len < endpos then
      reaper.MIDI_InsertNote(
        take, 
        true, 
        false, 
        start + div * ratchet, 
        endpos, 
        0, 
        pitch, 
        vel,
        false
      )
    end
  end
end

local function sortChord(chord, current_mode)
  table.sort(chord, function(a, b)
    if current_mode == "up" then
      return a.pitch < b.pitch
    else
      return a.pitch > b.pitch
    end
  end)
end

local function createArpeggio(direction, g_length, alternateStep, alternateLength)
    local take = reaper.MIDIEditor_GetTake(reaper.MIDIEditor_GetActive())
    if not take then return end
    local chord_gap_threshold = -1
    reaper.MIDI_Sort(take)
    adjustNoteLengths()
    local _, noteCount = reaper.MIDI_CountEvts(take)
    local chords = {}
    local chord = {}
    local lastEnd = 0
    -- 1) Gathering notes into chords
    local hasSelectedNotes = false
    for i = 0, noteCount - 1 do
        local retval, selected, _, _, _, _, _, _ = reaper.MIDI_GetNote(take, i)
        if selected then
            hasSelectedNotes = true
            break
        end
    end

    for i = 0, noteCount - 1 do
        local retval, selected, _, startpos, endpos, _, pitch, velocity = reaper.MIDI_GetNote(take, i)

        local noteLength = endpos - startpos
        if (not hasSelectedNotes or selected) and noteLength > 120 then
            if #chord > 0 and startpos - chord[#chord].endpos > 10 then -- You can change this threshold
                if #chord > 1 then
                    sortChord(chord, current_mode)
                    table.insert(chords, chord)
                else
                    table.insert(chords, {{startpos = chord[1].startpos, endpos = chord[1].endpos, pitch = chord[1].pitch}})
                end
                chord = {}
            end
            table.insert(chord, {startpos = startpos, endpos = endpos, pitch = pitch, velocity = velocity})
        end
    end
    if #chord == 1 then
        table.insert(chords, {{startpos = chord[1].startpos, endpos = chord[1].endpos, pitch = chord[1].pitch}})
    elseif #chord > 1 then
        sortChord(chord, current_mode)
        table.insert(chords, chord)
    end

    -- 2) Delete all notes
    for i = noteCount - 1, 0, -1 do
        local _, selected, _, startpos, endpos, _, _, _ = reaper.MIDI_GetNote(take, i)
        local noteLength = endpos - startpos
        if (not hasSelectedNotes or selected) and noteLength > 120 then
            reaper.MIDI_DeleteNote(take, i)
        end
    end

    -- 3) Insert arpeggios for each chord
    local chordZones = {}
    for chord_index, chord in ipairs(chords) do
        local insert_position = chord[1].startpos
        local end_position = chord[#chord].endpos

        table.insert(chordZones, {start = insert_position, stop = end_position})

        local current_step_grid = step_grid[(chord_index - 1) % #step_grid + 1]
        local current_mode

        if step_mode == 3 then
            current_mode = current_step_grid.mode or mode
        else
            current_mode = mode
        end

        if #chord == 1 then -- Если есть только одна нота
            while insert_position < end_position do
                local note_length = g_length
                if insert_position + note_length > end_position then
                    note_length = end_position - insert_position
                end

                reaper.MIDI_InsertNote(take, true, false, insert_position, insert_position + note_length, 0, chord[1].pitch, 100, false)
                insert_position = insert_position + note_length
            end
        else
            local note = 1
            local last_note = nil

            local current_step_grid = step_grid[(chord_index - 1) % #step_grid + 1]

            local main_count = 0 -- Основной счетчик для while цикла
            local step_counts = {}
            for i = 1, #current_step_grid do
                step_counts[i] = 0
            end

            local current_octave = 0 -- Эта переменная будет хранить текущую октаву
            while insert_position < end_position do
                local note_length = g_length
                local current_velocity = velocity -- Будем использовать эту переменную вместо оригинальной

                main_count = main_count + 1  -- Увеличиваем основной счетчик

                if step_mode == 2 and alternateStep and alternateLength then
                    if main_count % alternateStep == 0 then
                        note_length = alternateLength
                    end
                elseif step_mode == 3 then
                        local matched = false
                        if current_step_grid then
                            for i = #current_step_grid, 1, -1 do
                                step_counts[i] = step_counts[i] + 1
                                local v = current_step_grid[i]
                
                                if step_counts[i] % v.step == 0 then
                                    note_length = v.grid_step
                                    if v.velocity then
                                        current_velocity = v.velocity
                                    end
                                    if v.octave then
                                        current_octave = v.octave
                                    end
                                    if v.ratchet then  -- Новая строка для параметра ratchet
                                        ratchet = v.ratchet
                                    else
                                        ratchet = 1
                                    end
                                    matched = true
                                    break
                                end
                            end
                        end

                    if not matched and step_mode ~= 3 then
                        current_velocity = velocity
                        current_octave = octave
                    end
                else
                    current_velocity = chord[note].velocity
                end
                sortChord(chord, current_mode)
                if current_mode == "random" then
                    repeat
                        note = math.random(#chord)
                    until note ~= last_note or #chord == 1
                end

                last_note = note

                if insert_position + note_length > end_position then
                    note_length = end_position - insert_position
                end

                -- Взрыв октавы
                local pitch = chord[note].pitch + (current_octave * 12)
                if octave ~= 0 then
                    local randomOctaveShift = math.random(-octave, octave) * 12
                    pitch = pitch + randomOctaveShift -- Смещение на случайное количество октав вверх или вниз, сохраняя тон
                end
                    if ratchet and ratchet > 1 then
                        splitNote(take, insert_position, insert_position + note_length, pitch, current_velocity, ratchet)
                    else
                        reaper.MIDI_InsertNote(take, true, false, insert_position, insert_position + note_length, 0, pitch, current_velocity, false)
                    end
                
                reaper.MIDI_InsertNote(take, true, false, insert_position, insert_position + note_length, 0, pitch, current_velocity, false)
                insert_position = insert_position + note_length
                
                if current_mode ~= "random" then
                    note = (note % #chord) + 1
                end
            end
        end
    end
    if extendNotesFlag then
        for _, zone in ipairs(chordZones) do
            extendNotesToEndOfBar(zone.start, zone.stop)
        end
    end

    save_notes_to_json("modify.json")
end

--[[
reaper.Undo_BeginBlock()

reaper.Undo_EndBlock("Create Arpeggio from Chords", -1)]]

local currentValue = 0
CircleWidget = rtk.class('CircleWidget', rtk.Spacer)
CircleWidget.register{
    radius = rtk.Attribute{default=40},
    borderFraction = rtk.Attribute{default=1}, -- Доля границы (от 0 до 1)
    color = rtk.Attribute{type='color', default='red'},
    borderColor = rtk.Attribute{type='color', default='gray'},
    borderwidth = rtk.Attribute{default=5},
}
function CircleWidget:initialize(attrs, ...)
    rtk.Spacer.initialize(self, attrs, CircleWidget.attributes.defaults, ...)
    self.alpha2 = 0.07
    self.currentRadius = 0
end

function CircleWidget:_handle_draw(offx, offy, alpha, event)

    local sliderValueIndex = math.floor(slider_velocitythr.value / 10 + 0.5) + 1  -- округляем к ближайшему индексу
    if sliderValueIndex < 1 then sliderValueIndex = 1 end  -- защита от выхода индекса за пределы массива
    if sliderValueIndex > #grid_values then sliderValueIndex = #grid_values end
    
    
    sliderValueIndex = sliderValueIndex + 1
    
    local calc = self.calc
    local x = offx + calc.x + calc.w / 2
    local y = offy + calc.y + calc.h / 2
    --local knobRadius = calc.radius
    local knobRadius = calc.radius + self.currentRadius  -- добавляем текущее изменение радиуса
    
    local startAngle = 90
    local labels = {"Original","1/2", "1/3", "1/4", "1/6", "1/8", "1/12", "1/16",  "1/24", "1/32", "1/48", "1/64"}
    local stepAngle = 360 / #labels
    local labelRadius = knobRadius + 13
    local borderAngle = startAngle + 360 * (currentValue / (#labels - 1))
    local thickness = 12
    local alpha2 = 0.07
    
    for i = 1, 9 do
        local alpha = alpha2 * (10 - i)
        gfx.set(0, 0, 0, alpha)
        gfx.circle(x - 1, y + 4, knobRadius - calc.borderwidth - 17 + i, 20, true)
    end
    
    local outerRadius = math.floor(knobRadius - calc.borderwidth - 12)
    local steps = 20  -- Количество шагов градиента
    local stepSize = outerRadius / steps  -- Размер каждого шага
    local color = '#2a2a2a'
    for i = steps, 1, -1 do
        self:setcolor(color)
        gfx.circle(x, y, stepSize * i, 290, true)
        color = makeDarker(color, -0.035)
    end
        
        local markerAngle = math.rad(startAngle + stepAngle * currentValue)
        
        -- Расстояние от центра большого круга до метки (поменял на knobRadius - 5)
        local markerDistance = knobRadius - 55
        
        -- Координаты метки
        local markerX = x + markerDistance * math.cos(markerAngle)
        local markerY = y + markerDistance * math.sin(markerAngle)
        
        -- Округляем координаты
        markerX = math.floor(markerX + 0.5)
        markerY = math.floor(markerY + 0.5)
        
        bl = 3
        color = makeDarker(color, 0.065)
        self:setcolor(color)  -- Цвет метки, можно выбрать другой
        gfx.circle(markerX, markerY, 6, bl, true)
        
        local markerAngle = math.rad(startAngle + stepAngle * currentValue)
        
        -- Расстояние от центра большого круга до метки (поменял на knobRadius - 5)
        local markerDistance = knobRadius - 25
        
        -- Координаты метки
        local markerX = x + markerDistance * math.cos(markerAngle)
        local markerY = y + markerDistance * math.sin(markerAngle)
        
        -- Округляем координаты
        markerX = math.floor(markerX + 0.5)
        markerY = math.floor(markerY + 0.5)
        
        bl = 3
        color = makeDarker(color, -0.035)
        self:setcolor(color)  -- Цвет метки, можно выбрать другой
        gfx.circle(markerX, markerY, 5, bl, true)
        
        ---
    local innerRadius = math.floor((knobRadius - calc.borderwidth - 12) * 0.75)
    local steps = 10  -- Количество шагов градиента
    local stepSize = innerRadius / steps  -- Размер каждого шага
    local color = '#3a3a3a'
    for i = steps, 1, -1 do
        self:setcolor(color)
        gfx.circle(x, y, stepSize * i, 290, true)
        color = makeDarker(color, -0.091)
    end
    
    label_color=knob_rate_label_color
    label_round = 0.5
    
    --local sliderValueIndex = math.floor(self.value / 10) + 1  -- округляем вниз и прибавляем 1
    
    for i, label in ipairs(labels) do
        local angle = math.rad(startAngle + stepAngle * (i - 1))
        local lx = x + labelRadius * math.cos(angle)
        local ly = y + labelRadius * math.sin(angle)
        
        local isNearestLabel = math.abs(i - 1 - currentValue) < label_round
        local isNearestSlider = i == sliderValueIndex  -- новая переменная, которая проверяет, является ли текущая метка ближайшей для слайдера
    
        if step_mode == 2 and isNearestSlider then
            self:setcolor(advanced_color_main_sl_label)
        elseif isNearestLabel then
            self:setcolor(label_color)
        else
            self:setcolor('#8a8a8a')
        end
         --Book Antiqua
        gfx.setfont(1, "Palatino Linotype", 15)
        gfx.x = lx - gfx.measurestr(label) / 2
        gfx.y = ly -9
        gfx.drawstr(label)
    end

    
    local lineLengths = {5}  -- длины линий
    local lineCount = #lineLengths  -- количество разных длин линий
    local totalLines = #labels  -- общее количество линий
    local lineAngleStep = 360 / totalLines  -- шаг угла для каждой линии
    
    for i = 1, totalLines do
        local isNearestLabel = math.abs(i - 1 - currentValue) < label_round
        local isSliderLabel = i == sliderValueIndex  -- новая переменная
        
        if step_mode == 2 and isSliderLabel then  -- новая проверка
            self:setcolor(advanced_color_main_sl_label)
        elseif isNearestLabel then  
            self:setcolor(label_color)
        else
            self:setcolor('#8a8a8a')
        end
    
        local angle = math.rad(startAngle + lineAngleStep * (i - 1))
        local lineLength = lineLengths[(i - 1) % lineCount + 1]  -- выбор длины линии
        local x1 = x + (knobRadius - 5) * math.cos(angle)
        local y1 = y + 1 + (knobRadius - 5) * math.sin(angle)
        local x2 = x + (knobRadius - 5 - lineLength) * math.cos(angle)
        local y2 = y + 1 + (knobRadius - 5 - lineLength) * math.sin(angle)
    
        gfx.line(x1, y1, x2, y2, 1)
    end
    

    
end

local dragging = false
local prevY = nil
local sensitivity = 0.039  -- уменьшено для большей чувствительности
CircleWidget.currentValue = 0

CircleWidget.ondragstart = function(self, event, x, y, t)
    dragging = true
    prevY = y
    self.alpha2 = 0.02
    

    return true
end

CircleWidget.ondragend = function(self, event, dragarg)
    self:attr('cursor', nil)
    dragging = false
    prevY = nil
    self.alpha2 = 0.07

end

local lerpSpeed = 0.01
local lastNearestLabel = nil




CircleWidget.ondragmousemove = function(self, event, dragarg)
    if dragging and prevY then
        local delta = event.y - prevY
        currentValue = currentValue - delta * sensitivity
        currentValue = math.max(0, math.min(11, currentValue))  -- 11 - максимальное значение

        local nearestLabel = math.floor(currentValue)
        if currentValue - nearestLabel >= 0.5 then
            nearestLabel = nearestLabel + 1
        end

        if lastNearestLabel and math.abs(nearestLabel - lastNearestLabel) > 1 then
            nearestLabel = lastNearestLabel + math.sign(nearestLabel - lastNearestLabel)
        end

        lastNearestLabel = nearestLabel

        local threshold = 0.19

        if math.abs(currentValue - nearestLabel) < threshold then
            currentValue = nearestLabel
        else
            currentValue = currentValue * (1 - lerpSpeed) + nearestLabel * lerpSpeed
        end

        local borderFraction = currentValue / 11  -- 11 - максимальное значение
        self:attr('borderFraction', borderFraction)

        prevY = event.y
        self:onchange()
    end
end


CircleWidget.onmousewheel = function(self, event)
    local _, _, _, wheel_y = tostring(event):find("wheel=(%d+.?%d*),(-?%d+.?%d*)")
    wheel_y = tonumber(wheel_y)
    
    local step = 1  -- Шаг изменения. Можешь изменить, если нужно
    local nearestLabel = math.floor(currentValue)

    if wheel_y > 0 then
        nearestLabel = nearestLabel - step
    else
        nearestLabel = nearestLabel + step
    end

    nearestLabel = math.max(0, math.min(11, nearestLabel))  -- 11 - максимальное значение
    lastNearestLabel = nearestLabel
    
    currentValue = nearestLabel  -- Перемещаемся к ближайшей метке
    local borderFraction = currentValue / 11  -- 11 - максимальное значение
    self:attr('borderFraction', borderFraction)
    self:onchange()  -- Если у тебя есть какая-то дополнительная логика при изменении значения
    
    return true
end



function math.sign(x)
    return x > 0 and 1 or x < 0 and -1 or 0
end

local flag_unselect = false

function SelectNotesIfNoneSelected()
  local midi_editor = reaper.MIDIEditor_GetActive()
  if midi_editor ~= nil then
    local take = reaper.MIDIEditor_GetTake(midi_editor)
    if take ~= nil then
      local firstSelectedNote = reaper.MIDI_EnumSelNotes(take, -1)
      if firstSelectedNote == -1 then 
        reaper.MIDI_SelectAll(take, true)
        flag_unselect = true
      else 
        flag_unselect = false
      end
      
    end
  end
end

function unselect_all()
  local trackCount = reaper.CountTracks(0)
  for i = 0, trackCount - 1 do
    local track = reaper.GetTrack(0, i)
    local itemCount = reaper.CountTrackMediaItems(track)
    for j = 0, itemCount - 1 do
      local item = reaper.GetTrackMediaItem(track, j)
      local take = reaper.GetActiveTake(item)
      if take ~= nil then
        reaper.MIDI_SelectAll(take, false)
      end
    end
  end
end


function run()
  SelectNotesIfNoneSelected()
  local selected_pattern = {notes = {}}
  local take = reaper.MIDIEditor_GetTake(reaper.MIDIEditor_GetActive())
  local _, numNotes, _, _ = reaper.MIDI_CountEvts(take)
  for i = 0, numNotes - 1 do
    local _, selected, _, startppqpos, endppqpos, _, pitch, velocity = reaper.MIDI_GetNote(take, i)
    if selected then
      local position = startppqpos
      local length = endppqpos - position
      table.insert(selected_pattern.notes, {position = position, length = length, velocity = velocity, pitch = pitch})
    end
  end
  
  
  local modify_pattern = load_notes("modify.json")
  
  
  
  if compare_patterns(selected_pattern, modify_pattern) then
    local original_pattern = load_notes("original.json")
    delete_selected_notes(take)
    for i, note in ipairs(original_pattern.notes) do
      reaper.MIDI_InsertNote(take, true, false, note.position, note.position + note.length, 0, note.pitch, note.velocity, false)
    end
    createArpeggio(mode, grid, step, grid_step)
  else
    save_notes_to_json("original.json")
    createArpeggio(mode, grid, step, grid_step)
  end
  if flag_unselect == true then
    unselect_all()
  end
end

local lastRoundedValue = nil 

function original_notes()
      local selected_pattern = {notes = {}}
      local take = reaper.MIDIEditor_GetTake(reaper.MIDIEditor_GetActive())
      local _, numNotes, _, _ = reaper.MIDI_CountEvts(take)
      for i = 0, numNotes - 1 do
        local _, selected, _, startppqpos, endppqpos, _, pitch, velocity = reaper.MIDI_GetNote(take, i)
        if selected then
          local position = startppqpos
          local length = endppqpos - position
          table.insert(selected_pattern.notes, {position = position, length = length, velocity = velocity, pitch = pitch})
        end
      end
    local modify_pattern = load_notes("modify.json")
    if compare_patterns(selected_pattern, modify_pattern) then
      local original_pattern = load_notes("original.json")
      delete_selected_notes(take)
      for i, note in ipairs(original_pattern.notes) do
        reaper.MIDI_InsertNote(take, true, false, note.position, note.position + note.length, 0, note.pitch, note.velocity, false)
      end
    else
      save_notes_to_json("original.json")
    end 
end    


circt1=slider_line:add(CircleWidget{x=6,ref='circle', w=130, h=130, borderFraction=0/11})
function CircleWidget:onchange()
    if currentValue == 0 then
        original_notes()
    else
        local step = math.floor(currentValue + 0.5)  -- Округляем до ближайшего целого
    
        if lastRoundedValue ~= step then  -- Проверяем, изменилось ли округленное значение
            lastRoundedValue = step  -- Обновляем последнее округленное значение
    
            if step == 0 then
                -- Твой код для обработки step == 0
            else
                grid = grid_values[step]
                p_run()
            end
        end
        --reaper.ShowConsoleMsg("currentValue: " .. tostring(currentValue) .. " Rounded Step: " .. tostring(step) .. "\n")
    end
     
end
wnd:open()
